%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%
%%% Main Chapter 1 : Introduction  %%%
%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%
\chapter{Einleitung}
\label{chap:introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Über die Evolution der Betriebsysteme}
%\label{sec:evolution}
\section{Betriebsystemlehrveranstaltungen im Grundstudium}
\label{sec:motivation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		Seit der Einrichtung des Studiengangs Informatik um das Jahr 1970 in Deutschland haben sich die Studieninhalte, insbesondere im Bereich "`Praktische Informatik"', stark verändert.
		Dies ist auch nicht weiter verwunderlich, da wohl keine Wissenschaft einer derart schnellen Weiterentwicklung unterliegt.

		Beispielsweise wurde Ende der 70er Jahre durch Alan Kays neue Programmiersprache Smalltalk die Objektorientierung eingeführt und mit ihr die Paradigmen der Programmierung grundlegend verändert.
		Mitte der 80er wurde durch die Verbreitung von Patterns die Softwarearchitektur grundlegend vereinfacht und standardisiert.
		In den 90ern verbreiteten sich schließlich Netzwerktechnologien, auf die natürlich auch in der Lehre eingegangen werden musste.

		Nahezu als Konstante lässt sich jedoch feststellen, dass von Anbeginn bis Heute im Grundstudium bzw. Bachelor eine Vorlesung zum Thema Betriebssysteme zwingend vorgeschrieben ist.
		Dabei stellt sich bei vielen Studenten die Frage, warum trotz der zahlreichen modernen Abstraktionsschichten (e.g. VMs bei Java und .net) einer grundlegenden und hardwarenahem Veranstaltung nach wie vor eine derartige Wichtigkeit eingeräumt wird.
		% Meist wird vorgeschlagen, eine derartige Veranstaltung als Wahl im Master für Interesse Treiber / Betriebssystem

		%Ressourcen
		%Sicherheit
		%Überlast

		Diese Frage lässt sich recht gut beantworten, wenn man beispielsweise das Verhalten von Rechnern unter Ressourcenknappheit betrachtet.
		Hierbei existieren zahlreiche, auch für Anwendungsprogrammierer relevante Probleme, deren Lösung nur mit Fachwissen über die internen Mechanismen des verwendeten Betriebssystems möglich ist. 
		Beispielsweise entstehen ohne Kenntnisse über Scheduling leicht Fehler im Bereich der Nebenläufigkeit, die nicht selten Programme durch Dead-Locks unbenutzbar machen und durch die Beeinflussung des Systems durch einen Debugger enorm schwer zu beheben sind (Heisenbugs).


		% Single User Single Task to Multi User Multi Task Scheduler beobachten, etc.

		% 		Von DOS 1.0 zu Windows 8


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Behandlung in der Lehre}
\label{sec:teaching}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		Eine gute Möglichkeit die verschiedenen Funktionen eines heutigen Betriebssystems kennen zu lernen besteht darin, dessen Evolution nachzuvollziehen. Hierbei wird nicht nur die Funktionsweise, sondern auch die Notwendigkeit jedes Features deutlich. 
		Bekanntermaßen führt unter Windows 3.11 eine Endlosschleife zum Absturz des gesamten Systems, da beim kooperativen Multitasking die CPU nicht mehr freigegeben wird.
		Um dieses extrem häufige Ärgernis zu beseitigen wurde mit Windows 95 (teilweise) präemptives Multitasking eingeführt.

		In Vorlesungen wird dies meistens behandelt, indem  die Entwicklung anhand historischer Daten vorgetragen wird.
		Das Lernen von Fakten und Versionsnummern bzw. Jahreszahlen führt meist jedoch nicht zum gleichen Verständnis wie das selbstständige Nachvollziehen von Problemen und deren Lösungen.
		Die anderen Themen der Lehrveranstaltung werden daher meist mittels praktischer Experimente vertieft.
		Bei diesen lösen Studenten selbstständig oder in Gruppen bestimmte Aufgaben und erleben daher die Funktionalitäten praxisnah.
		Bislang werden diese meist auf dem eigenen Computer oder in bereitgestellten virtuellen Maschinen gelöst.
		Hierbei kommt es immer wieder zu Problemen durch die notwendige Einrichtung und verschiedenartige Konfigurationen.

		Ein besonders innovatives Verfahren zur praxisnahen Lehre wird hierbei vom Hasso-Plattner-Institut angewendet.
		Beim OpenStack basierten InstantLab ist es für Studenten nicht mehr notwendig, die Experimente auf eigener Hardware einzurichten und durchzuführen.
		Stattdessen wird ein http-basiertes Interface angeboten, auf dem die Studenten nach einem Login mit ihrer Benutzerkennung (die Authentifikation erfolgt hierbei über den zentralen LDAP-Server des Instituts) auf Knopfdruck neue Instanzen eines VM-Templates erzeugen können. 
		Diese Templates werden vorher vom Übungsleiter bei der Aufgabenstellung angelegt und enthalten jeweils die Konfiguration einer VM sowie ein Datenträgerimage mit installiertem Betriebssystem und den für das jeweilige Experiment notwendigen Dateien.
		Die Experimente können ebenfalls vollständig im Webbrowser durchgeführt werden, dabei kommt eine Javascript basierte VNC Implementierung zum Einsatz.
		Die VMs können dort am Ende gespeichert und zur Benotung eingereicht werden.
		Sollten es im Laufe der Durchführung zu Problemen oder Fehlern kommen, kann die Instanz jederzeit gelöscht und neu aufgesetzt werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thema der Arbeit}
\label{sec:topic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			


		%In dieser Arbeit sollen historische Betriebssysteme wieder ausführbar und erlebbar gemacht werden. 
		Ziel dieser Arbeit ist es, historische Betriebssysteme heutzutage für Studenten ausführbar zu machen.
		Da die damals verwendete Hardware schwer bis unmöglich zu replizieren ist, kommen hierbei virtuelle Maschinen zum Einsatz.
		Außerdem sollen mittels für diese Arbeit entwickelten und in diesen VMs ausführbaren Experimenten die Killer Features und die Neuerungen, aber auch die Nachteile, der jeweiligen Betriebssysteme erlebbar gemacht werden.
		
		Eine besondere Schwierigkeit liegt dabei darin begründet, dass die relevanten Systeme aufgrund ihres Alters längst das Ende des Supportzeitraums erreicht haben und auch von den Herstellern der Hypervisoren nicht mehr unterstützt werden oder noch nie unterstützt wurden.
		Daher existieren meist keine offiziellen Client-Treiber, dadurch ist insbesondere keine Paravirtualisierung möglich.
		Zudem ist die heutzutage virtualisierte Hardware meist deutlich neuer als diejenige, mit denen die Systeme ursprünglich auf Kompatibilität getestet wurden.

		Der Fokus liegt hierbei ausschließlich auf Betriebssystemen von Microsoft, da diese für heutige Programmierer die relevanteste Plattform darstellen.
		Zudem wurde hierbei stets auf Kompatibilität mit den Vorgängerversionen geachtet;
		insbesondere wurden allzu starke Veränderungen und komplette Neuentwicklungen größtenteils vermieden. 
		Daher lässt sich auf dieser Plattform die evolutionäre Weiterentwicklung der Software besonders gut beobachten. \\ \\

	
		%Desweiteren wurden von Microsoft alle Betriebssysteme für die Intel x86-Plattform angeboten, so dass auf Veränderungen des Systems durch unterschiedliche Hardware nicht geachtet werden muss.
		%Dass zwischenzeitlich auch andere Prozessoren, wie z.B. Itanium, von Windows NT unterstützt wurden, ist hierbei nicht von Relevanz. 

		%Gezielt Microsoft, historische Betriebssysteme und Killer-Features. 
				
		%Struktur

		Im Kapitel \ref{chap:challenges} (\nameref{chap:challenges}) werden die wichtigsten Ziele und Anforderungen erfasst. 
		Der Rest von Kapitel \ref{chap:challenges} ist der Recherche gewidmet; sowohl bestehende Lösungen als auch aktuelle akademische Diskussionen werden betrachtet.
		
		Das Hauptkapitel \ref{chap:setup} (\nameref{chap:setup}) dokumentiert die Erzeugung der Experimente von der Beschaffung historischer Betriebssysteme, der Wiederinbetriebnahme inkl. Anpassung an moderne Architekturen mittels spezieller Treiber bis zur Auswahl didaktisch geeigneter Experimente.
		Dabei wird zuerst der gewählte Ansatz und danach die konkreten Schritte für jede virtuelle Maschine vorgestellt.
		
		Das darauf folgenden Kapitel \ref{chap:experiments} (\nameref{chap:experiments}) beschreibt die Durchführung der Versuche und die zu erwartenden Ergebnisse aus Sicht des Studenten. Es kann später als Experimentierhandbuch verwendet werden.

		Zuletzt wird in Kapitel \ref{chap:evaluation} (\nameref{chap:evaluation}) das Ergebnis der Arbeit zusammenfassend dargestellt und bewertet, wobei auch auf noch nicht umgesetzte Ideen und Möglichkeiten eingegangen wird.
		

